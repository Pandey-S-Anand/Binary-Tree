/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

/* 
    Example of Inorder Traversal:

    Consider the following binary tree:

              1
            /   \
           2     3
         /  \     \
        4    5     6

    Inorder Traversal: Left → Root → Right

    1. Start at the root node (1).
        - Move to the left child node 2.

    2. Move to the left child of node 2 (node 4).
        - Visit node 4 → Add 4 to the list.
        - Node 4 has no children, so return to node 2.

    3. Visit node 2.
        - Visit node 2 → Add 2 to the list.
        - Move to the right child of node 2 (node 5).

    4. Visit node 5.
        - Visit node 5 → Add 5 to the list.
        - Node 5 has no children, so return to node 1.

    5. Visit node 1.
        - Visit node 1 → Add 1 to the list.
        - Move to the right child of node 1 (node 3).

    6. Move to the right child of node 3 (node 6).
        - Visit node 6 → Add 6 to the list.
        - Node 6 has no children, end traversal.

    Inorder Traversal Result: [4, 2, 5, 1, 3, 6]

    In Inorder Traversal, the nodes are visited in the following order:
    Left Subtree → Root → Right Subtree.
*/

//Naive approacch

//Recursive approach

class Solution {
    private List<Integer> inorder;

    public List<Integer> inorderTraversal(TreeNode root) {
        inorder = new ArrayList<>();
        // Perform the recursive inorder traversal
        performInorderTraversal(root);
        return inorder;
    }

    private void performInorderTraversal(TreeNode root) {
        // Base case: if the node is null, return immediately
        if (root == null) {
            return;
        }

        // Recur on the left subtree
        performInorderTraversal(root.left);

        // Add the value of the current node to the traversal list
        inorder.add(root.val);

        // Recur on the right subtree
        performInorderTraversal(root.right);
    }
}


//Iterative approach

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> inorder = new ArrayList<>();

        Deque<TreeNode> stack = new ArrayDeque<>();

        // Start with the root of the tree
        TreeNode currentNode = root;

        while (currentNode != null || !stack.isEmpty()) {
            // Reach the leftmost node (push all left nodes onto the stack)
            while (currentNode != null) {
                stack.push(currentNode);
                currentNode = currentNode.left;
            }

            // Pop the top node from the stack, this is the node that should be visited
            currentNode = stack.pop();

            // Add the value of the current node to the inorder traversal list
            inorder.add(currentNode.val);

            // Move to the right child of the current node
            currentNode = currentNode.right;
        }

        return inorder;
    }
}


//Optimal approach (Morris inorder traversal)

//With modification of the original tree structure

/*
 * Morris Inorder Traversal Dry Run:
 *
 * Input Tree:
 *         1
 *        / \
 *       2   5
 *      / \   \
 *     3   4   6
 *
 * Expected Inorder Traversal: [3, 2, 4, 1, 5, 6]
 *
 * ------------------------------------------------------------
 * Step 1: current = 1
 * - 1 has left child → find rightmost in left subtree (rightmost = 4)
 * - Create thread: 4.right = 1
 * - Move current to 2
 *
 * Tree after threading:
 *
 *       2   
 *      / \  
 *     3   4   
 *          \
 *           1
 *            \
 *             5
 *              \
 *               6
 *
 * ------------------------------------------------------------
 * Step 2: current = 2
 * - 2 has left child → rightmost in left subtree = 3
 * - Create thread: 3.right = 2
 * - Move current to 3
 *
 * Tree after threading:
 *
 *     3
 *      \
 *       2   
 *        \  
 *         4   
 *          \
 *           1
 *            \
 *             5
 *              \
 *               6
 *
 * ------------------------------------------------------------
 * Step 3: current = 3
 * - 3 has no left → add 3 to result
 * - Move right → move to 2
 *
 * Result so far: [3]
 *
 * ------------------------------------------------------------
 * Step 4: current = 2
 * - 2 has no left → add 2 to result
 * - Move right → move to 4
 *
 * Result so far: [3, 2]
 *
 * ------------------------------------------------------------
 * Step 5: current = 4
 * - 4 has no left → add 4 to result
 * - Move right → move to 1
 *
 * Result so far: [3, 2, 4]
 *
 * ------------------------------------------------------------
 * Step 6: current = 1
 * - 1 has no left → add 1 to result
 * - Move right → move to 5
 *
 * Result so far: [3, 2, 4, 1]
 *
 * ------------------------------------------------------------
 * Step 7: current = 5
 * - 5 has no left → add 5 to result
 * - Move right → move to 6
 *
 * Result so far: [3, 2, 4, 1, 5]
 *
 * ------------------------------------------------------------
 * Step 8: current = 6
 * - 6 has no left → add 6 to result
 * - Move to null (end)
 *
 * Final Result: [3, 2, 4, 1, 5, 6]
 */

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) {
            return Collections.emptyList();
        }

        List<Integer> inorder = new ArrayList<>();
        TreeNode currentNode = root;

        while (currentNode != null) {
            // Case 1: If there is no left subtree, process the node and move right
            if (currentNode.left == null) {
                inorder.add(currentNode.val);  // Add current node value to the list
                currentNode = currentNode.right;       // Move to the right subtree
            } else {
                // Case 2: If left subtree exists, find the rightmost node in the left subtree
                TreeNode rightmost = currentNode.left;

                // Move to the rightmost node in the left subtree
                while (rightmost.right != null) {
                    rightmost = rightmost.right;
                }

                // Create a temporary thread from the rightmost node to the current node
                rightmost.right = currentNode;
                TreeNode temp = currentNode;  // Store current node reference
                currentNode = currentNode.left;   // Move current to its left subtree

                // Remove the left link to avoid infinite loops
                temp.left = null;
            }
        }

        return inorder;
    }
}


//Without modification of the original tree structure

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) {
            return Collections.emptyList();
        }

        List<Integer> inorderList = new ArrayList<>();
        TreeNode current = root;

        while (current != null) {
            // Case 1: If there is no left subtree, process the node and move right
            if (current.left == null) {
                inorderList.add(current.val); // Add current node value to the list
                current = current.right; // Move to the right subtree
            } else {
                // Case 2: If left subtree exists, find the rightmost node in the left subtree
                TreeNode rightmost = current.left;

                // Move to the rightmost node in the left subtree
                /*
                 * rightmost.right != current condition is detecting the temporary link
                 * If rightmost.right is already pointing to current, we need to revert the changes we made.
                 */
                while (rightmost.right != null && rightmost.right != current) {
                    rightmost = rightmost.right;
                }

                if (rightmost.right == current) {
                    /*
                     * This condition indicates that we have finished processing the left subtree.
                     * We add the current node value to the result, remove the temporary link, and move to the right subtree.
                     */
                    inorderList.add(current.val); // Add current node value to the list
                    rightmost.right = null; // Revert the temporary link (remove the thread)
                    current = current.right; // Move to the right subtree
                } else {
                    // Create a temporary thread from the rightmost node to the current node
                    rightmost.right = current;
                    current = current.left; // Move to the left subtree
                }
            }
        }

        return inorderList;
    }
}
