/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */

/* 
    Example of Inorder Traversal:

    Consider the following binary tree:

              1
            /   \
           2     3
         /  \     \
        4    5     6

    Inorder Traversal: Left → Root → Right

    1. Start at the root node (1).
        - Move to the left child node 2.

    2. Move to the left child of node 2 (node 4).
        - Visit node 4 → Add 4 to the list.
        - Node 4 has no children, so return to node 2.

    3. Visit node 2.
        - Visit node 2 → Add 2 to the list.
        - Move to the right child of node 2 (node 5).

    4. Visit node 5.
        - Visit node 5 → Add 5 to the list.
        - Node 5 has no children, so return to node 1.

    5. Visit node 1.
        - Visit node 1 → Add 1 to the list.
        - Move to the right child of node 1 (node 3).

    6. Move to the right child of node 3 (node 6).
        - Visit node 6 → Add 6 to the list.
        - Node 6 has no children, end traversal.

    Inorder Traversal Result: [4, 2, 5, 1, 3, 6]

    In Inorder Traversal, the nodes are visited in the following order:
    Left Subtree → Root → Right Subtree.
*/


//Naive approacch

//Recursive approach

class Solution {
    private List<Integer> inorderTraversal;

    public List<Integer> inorderTraversal(TreeNode root) {
        inorderTraversal = new ArrayList<>();
        // Perform the recursive inorder traversal
        performInorderTraversal(root);
        return inorderTraversal;
    }

    private void performInorderTraversal(TreeNode root) {
        // Base case: if the node is null, return immediately
        if (root == null) {
            return;
        }

        // Recur on the left subtree
        performInorderTraversal(root.left);

        // Add the value of the current node to the traversal list
        inorderTraversal.add(root.val);

        // Recur on the right subtree
        performInorderTraversal(root.right);
    }
}


//Iterative approach


