//Bruteforce approach



//Optimal approach

class Solution {
    private Node head = null; // Pointer to the head of the flattened tree (new root)
    private Node tail = null; // Pointer to keep track of the last node in the flattened tree

    public Node flattenBST(Node root) {
        Node currentNode = root;

        while (currentNode != null) {
            if (currentNode.left == null) {
                // If there is no left child, append the current node to the flattened tree
                append(currentNode);
                currentNode = currentNode.right; // Move to the right child
            } else {
                // Find the rightmost node of the left subtree
                Node rightMostNode = currentNode.left;
                while (rightMostNode.right != null) {
                    rightMostNode = rightMostNode.right;
                }

                // Connect the rightmost node of the left subtree to the current node
                rightMostNode.right = currentNode;

                // Move current pointer to the left child and nullify the left pointer
                Node temp = currentNode;
                currentNode = currentNode.left;
                temp.left = null;
            }
        }

        return head; // Return the new root of the flattened tree (smallest node)
    }

    private void append(Node node) {
        if (head == null) {
            // If this is the first node being added, initialize head and tail
            head = tail = node;
        } else {
            // Link the current node to the flattened list and update tail
            tail.right = node;
            tail = node;
        }
    }
}
